## 数据代理

​		Vue中有数据代理，实现方式：创建Vue实例化对象时，传入配置对象到构造函数中，从配置对象中取出data对象保存到_data和data变量中，然后通过Object.keys对data对象中的所有属性进行遍历。遍历时，通过Object.defineProperty方法给vm添加上data对象中的属性并重写get和set方法，从而实现数据代理。



## 数据劫持

​		Vue在模板解析前会对data对象中的属性属性进行数据劫持操作，通过遍历data对象中的所有属性，每有一个属性都会创建一个dep对象做标记，并且再次通过Object.defineProperty方法定义了一次get和set方法。

​		数据劫持里的get在获取data对象中的属性时触发，内部回会去寻找模板中的表达式，每有一个表达式就会存在一个watcher对象，然后时watcher对象和dep对象产生关系(你中有我，我中有你。)，数据劫持中的get触发完毕后，才会返回data属性的值给表达式

​		数据劫持里的set在修改data对象中的属性时触发，内部会遍历dep中所有的watcher对象，通知watcher对象去更新数据，渲染到视图中。



模板中每有一个表达式就会创建一个wacther对象 

```javascript
<h2>{{msg}}<h2/>
<h3>{{msg}}<h3/>
{{msg}}---new Watcher
{{msg}}---new Watcher
```

data中每有一个属性名就会创建一个dep对象----obj---dep  name---dep

```javascript
data:{obj:{name:''} }
obj---new dep()
name---new dep()
```

dep和watcher的四种关系：

- 1对1关系：1个dep对应一个watcher data中只有一个属性，模板中只有一个表达式

- 1对多关系：1个dep对应多个watcher data中只有一个属性，模板中有多个相同的表达式

- 多对1关系：多个dep对应1个wathcer data是一个对象对象中有属性 ，模板中用了这个对象中的某一个属性

- 多对多关系：多个dep对应多个watcher data是一个对象对象中有属性，模板中使用了这个对象和多个属性

  

## 模板解析—表达式（插值语法）

​		在Vue实例化过程中，经历了数据代理，数据劫持后，就将进入模板解析阶段。创建模板解析对象，然后将vm实例和模板选择器传入模板解析构造函数中，构造函数中，内部会创建文档碎片对象(虚拟DOM)，根据选择器获取对应的html容器(id为app的div)，将容器下的所有子节点都放入文档碎片对象中去。

​		然后开始操作文档碎片节点对象，遍历所有子节点，判断是不是标签节点，再判断是不是文本节点并且符合插值语法的正则。然后还要判断是否有子节点，有子节点则进行递归操作。

​		判断是文本节点并符合插值语法，再通过正则取组的方式，将插值语法中的表达式名称取出，获得表达式名称再去vm实例中获取对应的属性值。然后将属性值替换插值语法本文节点。

​		最后将编译好的文档碎片节点(虚拟DOM)放回到html容器中，渲染到页面。



## 模板解析—普通指令

​		Vue实例化对象过程中，经历数据代理和数据劫持后，进入模板解析，将真实DOM中的所有子节点放入虚拟DOM中。对虚拟DOM下的所有子节点进行遍历：判断是否为标签节点或符合插值语法的文本节点。

​		是标签节点，则将标签中的所有属性节点取出，并进行遍历，判断属性节点是否是v-开头，是则判断为指令。

​		是指令，则获取指令中的表达式和`:`后面的属性名。再判断`:`后面是否是以on开头，是则属于事件指令，不是则属于是普通指令。

​		是普通指令，通过调用指定指令的编译方法，将表达式值直接渲染到标签中，或创建指定属性并赋予表达式的值。

​		最后将该标签中的所有v-开头的指令移除，并渲染界面。



## 模板解析—事件指令

​		Vue实例化对象过程中，经历了数据代理和数据劫持后，进行模板解析，将对应html容器中的所有子节点全部放入虚拟DOM中，然后操作虚拟DOM中的所有子节点进行遍历：判断子节点是不是标签节点或符合插值语法的文本节点。

​		是标签节点，则取出标签中的所有属性节点，进行遍历：判断属性是否是以V-开头，是则说明是指令。

​		是指令，则获取表达式的值，并获取`:`后的字符串，然后判断`:`前是否是以on开头，是则说明是事件指令，不是则说明是普通指令。

​		是事件指令，则vm实例获取表达式对应的事件回调函数，通过addEventListener()方法，为该标签绑定`:`后字符串为事件类型的事件。

​		最后将该标签中的所有v-开头的指令移除，并渲染界面。



## 双向数据绑定

​		Vue实例化对象过程中，内部经过数据代理，数据劫持。然后开始进行模板解析操作。将html容器中所有的子节点全部放入虚拟DOM中，对象虚拟DOM中的所有子节点进行遍历：判断是否为标签节点或是否为符合插值语法的文本节点。

​		是标签节点，取出所有的属性节点，进行遍历：判断属性是否是以v-开头，是则判断为指令。

​		是指令，获取指令中表达式中的值，再判断v-后面是否有on，有则为事件指令，没有则为普通指令。

​	   v-model是普通指令，截取掉v-，调用指定的model指令的方法，model指令方法中，会通过addEventListener给当前标签绑定input事件及对应回调。

​		如果页面中修改了文本框的值，此时调用触发input事件中的回调，获取当前文本框中的value值，model指令对应的表达式的值对比，如果变化了，就会触发数据代理中的set方法和数据劫持中的set方法，然后通知属性对应的dep对象通知其subs数组中的所有watcher对象，进行表达式数据的更新，表达式发送变化，页面自动重新渲染，从而实现响应式数据操作。

## Vue的生命周期

- beforeCreate  ----  数据创建之前（data和methods数据没有初始化完成）
- created  ----  数据创建完毕（data和methods数据有了，可以发送异步请求）
- beforeMount  ----  页面加载之前（相当于页面开始模板解析）
- Mounted  ----  页面加载完毕（页面加载完毕，   DOM全部创建完毕）
- beforeUpdate  ----  数据和页面更新之前
- updated  ----  数据和页面更新完毕
- beforeDestroy  ----  销毁之前（vm实例还可以使用）
- destroyed  ----  销毁完毕（实例无法正常运行）

扩展：

- errorCaptured  ----  捕获自己组件错误（用于定义在可能会报错的子组件的父组件中，有三个参数err错误对象，child报错的子组件，info错误信息，通过什么事件触发的报错）

使用`<keep-alive></keep-alive>`包裹路由组件时可以使没有激活的组件缓存起来而不是直接销毁，此时可以激活下面两个生命周期

- activated  ----  组件激活时触发（路由缓存激活）
- deactivated  ----  组件失效 但没有销毁（路由缓存离开）

